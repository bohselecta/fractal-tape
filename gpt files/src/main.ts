import './style.css';
import { asciiPool, normalizeWords, minePhrases } from './glyphDict';
import { buildTrie, encodeWithTrie, minDepthForSlots, toBase3 } from './encoder';
import { computePositions, drawBaseTriangle, drawGrid, worldToScreen, screenToWorld, type Transform } from './viewer';
const el = { input: document.getElementById('input'), glyphed: document.getElementById('glyphed'), kbIn: document.getElementById('kbIn'), kbOut: document.getElementById('kbOut'), ratio: document.getElementById('ratio'), counts: document.getElementById('counts'), depthD: document.getElementById('depthD'), max: document.getElementById('maxGlyphs'), zoomInfo: document.getElementById('zoomInfo'), reset: document.getElementById('reset'), toggleGrid: document.getElementById('toggleGrid'), glyphNow: document.getElementById('glyphNow'), loadGlyphs: document.getElementById('loadGlyphs'), saveGlyphs: document.getElementById('saveGlyphs'), topK: document.getElementById('topK'), nMin: document.getElementById('nMin'), nMax: document.getElementById('nMax'), canvas: document.getElementById('view') } as any;
const ctx = (el.canvas as HTMLCanvasElement).getContext('2d')!;
type GlyphEntry = { phrase: string[]; glyph: string };
let CURRENT: GlyphEntry[] = [];
const getGlyphs = ()=> CURRENT;
const setGlyphs = (g: GlyphEntry[])=> { CURRENT = g; };
function toKB(n:number){ return (n/1024).toFixed(2)+' KB'; }
const t: Transform = { scale: 0.9 * Math.min((el.canvas as HTMLCanvasElement).width, (el.canvas as HTMLCanvasElement).height), zoom: 1, offset: { x: (el.canvas as HTMLCanvasElement).width*0.05, y: (el.canvas as HTMLCanvasElement).height*0.05 } };
let showGrid = false, panning=false, anchor={x:0,y:0}, off0={x:0,y:0};
let tokens: string[] = [];
let D = 0;
let positions: {x:number;y:number}[] = [];
function render(){ ctx.clearRect(0,0,(el.canvas as HTMLCanvasElement).width,(el.canvas as HTMLCanvasElement).height); ctx.fillStyle = '#0b0e14'; ctx.fillRect(0,0,(el.canvas as HTMLCanvasElement).width,(el.canvas as HTMLCanvasElement).height); drawBaseTriangle(ctx, t); if (showGrid){ const est = Math.max(1, Math.min(8, Math.floor(Math.log2(t.zoom*2)))); drawGrid(ctx, t, est); } const pxCell = (t.scale * t.zoom) * (1 / (2 ** D)); const drawLabel = pxCell >= 5; const limit = parseInt((el.max as HTMLInputElement).value, 10); ctx.shadowColor = 'rgba(72,255,210,0.35)'; ctx.shadowBlur = 10; for (let i=0;i<positions.length && i<limit;i++){ const p = worldToScreen(t, positions[i]); if (p.x<-50 || p.y<-50 || p.x>(el.canvas as HTMLCanvasElement).width+50 || p.y>(el.canvas as HTMLCanvasElement).height+50) continue; if (drawLabel){ ctx.fillStyle = '#a2ffef'; ctx.font = Math.max(10, pxCell) + 'px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace'; ctx.fillText(tokens[i], p.x, p.y); } else { ctx.fillStyle = '#2bd1ff'; ctx.beginPath(); ctx.arc(p.x, p.y, 1.5, 0, Math.PI*2); ctx.fill(); } } (el.zoomInfo as HTMLElement).textContent = `zoom ${t.zoom.toFixed(2)} • cell ${pxCell.toFixed(1)}px`; }
function updateAll(){ const words = normalizeWords((el.input as HTMLTextAreaElement).value); const trie = buildTrie(getGlyphs()); tokens = encodeWithTrie(words, trie); (el.glyphed as HTMLTextAreaElement).value = tokens.join(' '); const enc = new TextEncoder(); const inB = enc.encode((el.input as HTMLTextAreaElement).value).length; const outB = enc.encode((el.glyphed as HTMLTextAreaElement).value).length; (el.kbIn as HTMLElement).textContent = toKB(inB); (el.kbOut as HTMLElement).textContent = toKB(outB); (el.ratio as HTMLElement).textContent = inB ? `${(((inB - outB) / inB) * 100).toFixed(1)}%` : '0%'; (el.counts as HTMLElement).textContent = `${words.length}→${tokens.length}`; D = Math.max(1, minDepthForSlots(tokens.length || 1)); (el.depthD as HTMLElement).textContent = String(D); positions = computePositions(tokens.length, toBase3, D); render(); }
(el.canvas as HTMLCanvasElement).addEventListener('wheel', (ev:any)=>{ ev.preventDefault(); const f = Math.exp(-ev.deltaY * 0.001); const rect = (el.canvas as HTMLCanvasElement).getBoundingClientRect(); const m = { x: ev.clientX - rect.left, y: ev.clientY - rect.top }; const before = screenToWorld(t, m); t.zoom = Math.max(.2, Math.min(6, t.zoom * f)); const after = screenToWorld(t, m); t.offset.x += (after.x - before.x) * t.scale * t.zoom; t.offset.y += (after.y - before.y) * t.scale * t.zoom; render(); }, {passive:false});
(el.canvas as HTMLCanvasElement).addEventListener('mousedown', (ev:any)=>{ panning=true; anchor={x:ev.clientX,y:ev.clientY}; off0={...t.offset}; });
window.addEventListener('mouseup', ()=>{ panning=false; });
window.addEventListener('mousemove', (ev:any)=>{ if(!panning) return; t.offset.x = off0.x + (ev.clientX-anchor.x); t.offset.y = off0.y + (ev.clientY-anchor.y); render(); });
(el.reset as HTMLButtonElement).onclick = ()=>{ t.zoom=1; t.offset={ x: (el.canvas as HTMLCanvasElement).width*0.05, y: (el.canvas as HTMLCanvasElement).height*0.05 }; render(); };
(el.toggleGrid as HTMLButtonElement).onclick = ()=>{ showGrid = !showGrid; render(); };
(el.max as HTMLInputElement).oninput = render;
function trainGlyphsFromText(text: string, top=128, nMin=2, nMax=5){ const words = normalizeWords(text); const cands = minePhrases(words, nMin, nMax); const pool = asciiPool('~', 2); const take = Math.min(top, pool.length, cands.length); const trained = Array.from({length: take}, (_,i)=>({ phrase: cands[i].phrase, glyph: pool[i] })); setGlyphs([...trained]); }
(el.glyphNow as HTMLButtonElement).onclick = ()=>{ const top = Math.max(16, Math.min(1024, parseInt((el.topK as HTMLInputElement).value||'128',10))); const nMin = Math.max(2, Math.min(8, parseInt((el.nMin as HTMLInputElement).value||'2',10))); const nMax = Math.max(nMin, Math.min(8, parseInt((el.nMax as HTMLInputElement).value||'5',10))); trainGlyphsFromText((el.input as HTMLTextAreaElement).value, top, nMin, nMax); updateAll(); };
(el.loadGlyphs as HTMLButtonElement).onclick = ()=>{ const i = document.createElement('input'); i.type='file'; i.accept='application/json'; i.onchange = async ()=>{ if(!i.files?.[0]) return; const txt = await i.files[0].text(); const arr = JSON.parse(txt); if (Array.isArray(arr) && arr.length) { setGlyphs(arr); updateAll(); } }; i.click(); };
(el.saveGlyphs as HTMLButtonElement).onclick = ()=>{ const blob = new Blob([JSON.stringify(getGlyphs(), null, 2)], {type:'application/json'}); const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='glyphs.json'; a.click(); URL.revokeObjectURL(a.href); };
(el.input as HTMLTextAreaElement).value = "lorem ipsum dolor sit amet, consectetur adipiscing elit. sed erat erat, pulvinar non tincidunt sit amet...";
updateAll();
(el.input as HTMLTextAreaElement).addEventListener('input', ()=>{ updateAll(); });
